# API reference: pb_decode.h

## Input stream management

### pb_istream_from_buffer

Helper function for creating an input stream that reads data from a
memory buffer.

    pb_decode_ctx_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| buf                  | Pointer to byte array to read from.
| bufsize              | Size of the byte array. Typically length of the message to be decoded.
| returns              | An input stream ready to use.

### pb_read

Read data from input stream. Always use this function, don't try to
call the stream callback directly.

    bool pb_read(pb_decode_ctx_t *stream, pb_byte_t *buf, size_t count);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from.
| buf                  | Buffer to store the data to, or `NULL` to just read data without storing it anywhere.
| count                | Number of bytes to read.
| returns              | True on success, false if `stream->bytes_left` is less than `count` or if an IO error occurs.

End of file is signalled by `stream->bytes_left` being zero after pb_read returns false.

## Message decoding

### pb_decode

Read and decode all fields of a structure. Reads until EOF on input
stream.

    bool pb_decode(pb_decode_ctx_t *stream, const pb_msgdesc_t *fields, void *dest_struct);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from.
| fields               | Message descriptor, usually autogenerated.
| dest_struct          | Pointer to message structure where data will be stored.
| returns              | True on success, false on any error condition. Error message will be in `stream->errmsg`.

In Protocol Buffers binary format, end-of-file is only allowed between fields.
If it happens anywhere else, pb_decode will return `false`. If
pb_decode returns `false`, you cannot trust any of the data in the
structure.

For optional fields, this function applies the default value and sets
`has_<field>` to false if the field is not present.

If `PB_ENABLE_MALLOC` is defined, this function may allocate storage
for any pointer type fields. In this case, you have to call
[pb_release](#pb_release) to release the memory after you are done with
the message. On error return `pb_decode` will release the memory itself.

### pb_decode_ex

Same as [pb_decode](#pb_decode), but allows extended options.

    bool pb_decode_ex(pb_decode_ctx_t *stream, const pb_msgdesc_t *fields, void *dest_struct, unsigned int flags);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from.
| fields               | Message descriptor, usually autogenerated.
| dest_struct          | Pointer to message structure where data will be stored.
| flags                | Extended options, see below
| returns              | True on success, false on any error condition. Error message will be in `stream->errmsg`.

The following options can be defined and combined with bitwise `|` operator:

* `PB_DECODE_NOINIT`: Do not initialize structure before decoding. This can be used to combine multiple messages, or if you have already initialized the message structure yourself.

* `PB_DECODE_DELIMITED`: Expect a length prefix in varint format before message. The counterpart of `PB_ENCODE_DELIMITED`.

* `PB_DECODE_NULLTERMINATED`: Expect the message to be terminated with zero tag. The counterpart of `PB_ENCODE_NULLTERMINATED`.

If `PB_ENABLE_MALLOC` is defined, this function may allocate storage
for any pointer type fields. In this case, you have to call
[pb_release](#pb_release) to release the memory after you are done with
the message. On error return `pb_decode_ex` will release the memory
itself.

### pb_release

Releases any dynamically allocated fields:

    void pb_release(const pb_msgdesc_t *fields, void *dest_struct);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| fields               | Message descriptor, usually autogenerated.
| dest_struct          | Pointer to structure where data is stored. If `NULL`, function does nothing.

This function is only available if `PB_ENABLE_MALLOC` is defined. It
will release any pointer type fields in the structure and set the
pointers to `NULL`.

This function is safe to call multiple times, calling it again does nothing.

## Manual field decoding

### pb_decode_tag

Decode the tag that comes before field in the protobuf encoding:

    bool pb_decode_tag(pb_decode_ctx_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from.
| wire_type            | Pointer to variable where to store the wire type of the field.
| tag                  | Pointer to variable where to store the tag of the field.
| eof                  | Pointer to variable where to store end-of-file status.
| returns              | True on success, false on error or EOF.

When the message (stream) ends, this function will return `false` and set
`eof` to true. On other errors, `eof` will be set to false.

### pb_skip_field

Remove the data for a field from the stream, without actually decoding it:

    bool pb_skip_field(pb_decode_ctx_t *stream, pb_wire_type_t wire_type);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from.
| wire_type            | Type of field to skip.
| returns              | True on success, false on IO error.

This function determines the amount of bytes to read based on the wire type.
For `PB_WT_STRING`, it will read the length prefix of a string or submessage
to determine its length.

### Callback field decoders
The functions with names `pb_decode_<datatype>` are used when dealing with callback fields.
The typical reason for using callbacks is to have an array of unlimited size.
In that case, [pb_decode](#pb_decode) will call your callback function repeatedly,
which can then store the values into e.g. filesystem in the order received in.

For decoding numeric (including enumerated and boolean) values, use
[pb_decode_varint](#pb_decode_varint), [pb_decode_svarint](#pb_decode_svarint),
[pb_decode_fixed32](#pb_decode_fixed32) and [pb_decode_fixed64](#pb_decode_fixed64).
They take a pointer to a 32- or 64-bit C variable, which you may then cast to smaller datatype for storage.

For decoding strings and bytes fields, the length has already been decoded and the callback function is given a length-limited substream.
You can therefore check the total length in `stream->bytes_left` and read the data using [pb_read](#pb_read).

Finally, for decoding submessages in a callback, use [pb_decode](#pb_decode) and pass it the `SubMessage_fields` descriptor array.

#### pb_decode_varint

Read and decode a [varint](http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints)
encoded integer.

    bool pb_decode_varint(pb_decode_ctx_t *stream, uint64_t *dest);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from. 1-10 bytes will be read.
| dest                 | Storage for the decoded integer. Value is undefined on error.
| returns              | True on success, false if value exceeds uint64_t range or an IO error happens.

#### pb_decode_varint32

Same as `pb_decode_varint`, but limits the value to 32 bits:

    bool pb_decode_varint32(pb_decode_ctx_t *stream, uint32_t *dest);

Parameters are the same as `pb_decode_varint`. This function can be used
for decoding lengths and other commonly occurring elements that you know
shouldn't be larger than 32 bit. It will return an error if the value
exceeds the `uint32_t` datatype.

#### pb_decode_svarint

Similar to [pb_decode_varint](#pb_decode_varint), except that it
performs zigzag-decoding on the value. This corresponds to the Protocol
Buffers `sint32` and `sint64` datatypes. :

    bool pb_decode_svarint(pb_decode_ctx_t *stream, int64_t *dest);

(parameters are the same as [pb_decode_varint](#pb_decode_varint))

#### pb_decode_fixed32

Decode a `fixed32`, `sfixed32` or `float` value.

    bool pb_decode_fixed32(pb_decode_ctx_t *stream, void *dest);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from. 4 bytes will be read.
| dest                 | Pointer to destination `int32_t`, `uint32_t` or `float`.
| returns              | True on success, false on IO errors.

This function reads 4 bytes from the input stream. On big endian
architectures, it then reverses the order of the bytes. Finally, it
writes the bytes to `dest`.

#### pb_decode_fixed64

Decode a `fixed64`, `sfixed64` or `double` value. :

    bool pb_decode_fixed64(pb_decode_ctx_t *stream, void *dest);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from. 8 bytes will be read.
| dest                 | Pointer to destination `int64_t`, `uint64_t` or `double`.
| returns              | True on success, false on IO errors.

Same as [pb_decode_fixed32](#pb_decode_fixed32), except this reads 8
bytes.

#### pb_decode_double_as_float

Decodes a 64-bit `double` value into a 32-bit `float`
variable. Counterpart of [pb_encode_float_as_double](#pb_encode_float_as_double). :

    bool pb_decode_double_as_float(pb_decode_ctx_t *stream, float *dest);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Input stream to read from. 8 bytes will be read.
| dest                 | Pointer to destination *float*.
| returns              | True on success, false on IO errors.

#### pb_make_string_substream

Decode the length for a field with wire type `PB_WT_STRING` and create
a substream for reading the data.

    bool pb_make_string_substream(pb_decode_ctx_t *stream, pb_decode_ctx_t *substream);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Original input stream to read the length and data from.
| substream            | Storage for a new substream that has limited length. Filled in by the function.
| returns              | True on success, false if reading the length fails.

This function uses `pb_decode_varint` to read an integer from the stream.
This is interpreted as a number of bytes, and the substream is set up so that its `bytes_left` is initially the same as the
length, and its callback function and state the same as the parent stream.

#### pb_close_string_substream

Close the substream created with
[pb_make_string_substream](#pb_make_string_substream).

    void pb_close_string_substream(pb_decode_ctx_t *stream, pb_decode_ctx_t *substream);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Original input stream to read data from.
| substream            | Substream to close

This function copies back the state from the substream to the parent stream,
and throws away any unread data from the substream.
It must be called after done with the substream.
