# API reference: pb.h

## Data types

### pb_byte_t

Type used for storing byte-sized data, such as raw binary input and
bytes-type fields.

    typedef uint_least8_t pb_byte_t;

For most platforms this is equivalent to `uint8_t`. Some platforms
however do not support 8-bit variables, and on those platforms 16 or 32
bits need to be used for each byte.

### pb_size_t

Type used for storing tag numbers and sizes of message fields. By
default the type is 16-bit:

    typedef uint_least16_t pb_size_t;

If tag numbers or fields larger than 65535 are needed, `PB_FIELD_32BIT`
option can be used to change the type to 32-bit value.

### pb_type_t

Type used to store the type of each field, to control the
encoder/decoder behaviour.

    typedef uint_least8_t pb_type_t;

The low-order nibble of the enumeration values defines the function that
can be used for encoding and decoding the field data:

| LTYPE identifier                 |Value  |Storage format
| ---------------------------------|-------|------------------------------------------------
| `PB_LTYPE_BOOL`                  |0x00   |Boolean.
| `PB_LTYPE_VARINT`                |0x01   |Integer.
| `PB_LTYPE_UVARINT`               |0x02   |Unsigned integer.
| `PB_LTYPE_SVARINT`               |0x03   |Integer, zigzag encoded.
| `PB_LTYPE_FIXED32`               |0x04   |32-bit integer or floating point.
| `PB_LTYPE_FIXED64`               |0x05   |64-bit integer or floating point.
| `PB_LTYPE_BYTES`                 |0x06   |Structure with `size_t` field and byte array.
| `PB_LTYPE_STRING`                |0x07   |Null-terminated string.
| `PB_LTYPE_SUBMESSAGE`            |0x08   |Submessage structure.
| `PB_LTYPE_SUBMSG_W_CB`           |0x09   |Submessage with pre-decoding callback.
| `PB_LTYPE_EXTENSION`             |0x0A   |Pointer to `pb_extension_t`.
| `PB_LTYPE_FIXED_LENGTH_BYTES`    |0x0B   |Inline `pb_byte_t` array of fixed size.

The bits 4-5 define whether the field is required, optional or repeated.
There are separate definitions for semantically different modes, even
though some of them share values and are distinguished based on values
of other fields:

 |HTYPE identifier     |Value  |Field handling
 |---------------------|-------|--------------------------------------------------------------------------------------------
 |`PB_HTYPE_REQUIRED`  |0x00   |Verify that field exists in decoded message.
 |`PB_HTYPE_OPTIONAL`  |0x10   |Use separate `has_<field>` boolean to specify whether the field is present.
 |`PB_HTYPE_SINGULAR`  |0x10   |Proto3 field, which is present when its value is non-zero.
 |`PB_HTYPE_REPEATED`  |0x20   |A repeated field with preallocated array. Separate `<field>_count` for number of items.
 |`PB_HTYPE_FIXARRAY`  |0x20   |A repeated field that has constant length.
 |`PB_HTYPE_ONEOF`     |0x30   |Oneof-field, only one of each group can be present.

The bits 6-7 define the how the storage for the field is allocated:

|ATYPE identifier     |Value  |Allocation method
|---------------------|-------|--------------------------------------------------------------------------------------------
|`PB_ATYPE_STATIC`    |0x00   |Statically allocated storage in the structure.
|`PB_ATYPE_POINTER`   |0x80   |Dynamically allocated storage. Struct field contains a pointer to the storage.
|`PB_ATYPE_CALLBACK`  |0x40   |A field with dynamic storage size. Struct field contains a pointer to a callback function.

### pb_msgdesc_t

Autogenerated structure that contains information about a message and
pointers to the field descriptors. Use functions defined in
`pb_common.h` to process the field information.

    typedef struct pb_msgdesc_s pb_msgdesc_t;
    struct pb_msgdesc_s {
        pb_size_t field_count;
        const uint32_t *field_info;
        const pb_msgdesc_t * const * submsg_info;
        const pb_byte_t *default_value;

        bool (*field_callback)(pb_decode_ctx_t *istream, pb_encode_ctx_t *ostream, const pb_field_iter_t *field);
    };

|                 |                                                        |
|-----------------|--------------------------------------------------------|
|`field_count`    | Total number of fields in the message.
|`field_info`     | Pointer to compact representation of the field information.
|`submsg_info`    | Pointer to array of pointers to descriptors for submessages.
|`default_value`  | Default values for this message as an encoded protobuf message.
|`field_callback` | Function used to handle all callback fields in this message. By default `pb_default_field_callback()`  which loads per-field callbacks from a `pb_callback_t` structure.

### pb_field_iter_t

Describes a single structure field with memory position in relation to
others. The field information is stored in a compact format and loaded
into `pb_field_iter_t` by the functions defined in `pb_common.h`.

    typedef struct pb_field_iter_s pb_field_iter_t;
    struct pb_field_iter_s {
        const pb_msgdesc_t *descriptor;
        void *message;

        pb_size_t index;
        pb_size_t field_info_index;
        pb_size_t required_field_index;
        pb_size_t submessage_index;

        pb_size_t tag;
        pb_size_t data_size;
        pb_size_t array_size;
        pb_type_t type;

        void *pField;
        void *pData;
        void *pSize;

        const pb_msgdesc_t *submsg_desc;
    };

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| descriptor           | Pointer to `pb_msgdesc_t` for the message that contains this field.
| message              | Pointer to the start of the message structure.
| index                | Index of the field inside the message
| field_info_index     | Index to the internal `field_info` array
| required_field_index | Index that counts only the required fields
| submessage_index     | Index that counts only submessages
| tag                  | Tag number defined in `.proto` file for this field.
| data_size            | `sizeof()` of the field in the structure. For repeated fields this is for a single array entry.
| array_size           | Maximum number of items in a statically allocated array.
| type                 | Type ([pb_type_t](#pb_type_t)) of the field.
| pField               | Pointer to the field storage in the structure.
| pData                | Pointer to data contents. For arrays and pointers this can be different than `pField`.
| pSize                | Pointer to count or has field, or NULL if this field doesn't have such.
| submsg_desc          | For submessage fields, points to the descriptor for the submessage.

By default [pb_size_t](#pb_size_t) is 16-bit, limiting the sizes and
tags to 65535. The limit can be raised by defining `PB_FIELD_32BIT`.

### pb_bytes_array_t

An byte array with a field for storing the length:

    typedef struct {
        pb_size_t size;
        pb_byte_t bytes[1];
    } pb_bytes_array_t;

In an actual array, the length of `bytes` may be different. The macros
`PB_BYTES_ARRAY_T()` and `PB_BYTES_ARRAY_T_ALLOCSIZE()`
are used to allocate variable length storage for bytes fields.

### pb_callback_t

Part of a message structure, for fields with type PB_HTYPE_CALLBACK:

    typedef struct _pb_callback_t pb_callback_t;
    struct _pb_callback_t {
        union {
            bool (*decode)(pb_decode_ctx_t *stream, const pb_field_iter_t *field, void **arg);
            bool (*encode)(pb_encode_ctx_t *stream, const pb_field_iter_t *field, void * const *arg);
        } funcs;

        void *arg;
    };

A pointer to the *arg* is passed to the callback when calling. It can be
used to store any information that the callback might need. Note that
this is a double pointer. If you set `field.arg` to point to
`&data` in your main code, in the callback you can access it like this:

    myfunction(*arg);           /* Gives pointer to data as argument */
    myfunction(*(data_t*)*arg); /* Gives value of data as argument */
    *arg = newdata;             /* Alters value of field.arg in structure */

When calling [pb_encode](#pb_encode), `funcs.encode` is used, and
similarly when calling [pb_decode](#pb_decode), `funcs.decode` is used.
The function pointers are stored in the same memory location but are of
incompatible types. You can set the function pointer to NULL to skip the
field.

### pb_wire_type_t

Protocol Buffers wire types. These are used with
[pb_encode_tag](#pb_encode_tag). :

    typedef enum {
        PB_WT_VARINT = 0,
        PB_WT_64BIT  = 1,
        PB_WT_STRING = 2,
        PB_WT_32BIT  = 5
    } pb_wire_type_t;

### pb_extension_type_t

Defines the handler functions and auxiliary data for a field that
extends another message. Usually autogenerated by
`nanopb_generator.py`.

    typedef struct {
        bool (*decode)(pb_decode_ctx_t *stream, pb_extension_t *extension,
                   uint32_t tag, pb_wire_type_t wire_type);
        bool (*encode)(pb_encode_ctx_t *stream, const pb_extension_t *extension);
        const void *arg;
    } pb_extension_type_t;

In the normal case, the function pointers are `NULL` and the decoder and
encoder use their internal implementations. The internal implementations
assume that `arg` points to a [pb_field_iter_t](#pb_field_iter_t)
that describes the field in question.

To implement custom processing of unknown fields, you can provide
pointers to your own functions. Their functionality is mostly the same
as for normal callback fields, except that they get called for any
unknown field when decoding.

### pb_extension_t

Ties together the extension field type and the storage for the field
value. For message structs that have extensions, the generator will
add a `pb_extension_t*` field. It should point to a linked list of
extensions.

    typedef struct {
        const pb_extension_type_t *type;
        void *dest;
        pb_extension_t *next;
        bool found;
    } pb_extension_t;

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| type                 | Pointer to the structure that defines the callback functions.
| dest                 | Pointer to the variable that stores the field value (as used by the default extension callback functions.)
| next                 | Pointer to the next extension handler, or `NULL` for last handler.
| found                | Decoder sets this to true if the extension was found.

## Utility macros

### PB_GET_ERROR

Get the current error message from a stream, or a placeholder string if
there is no error message:

    #define PB_GET_ERROR(stream) (string expression)

This should be used for printing errors, for example:

    if (!pb_decode(...))
    {
        printf("Decode failed: %s\n", PB_GET_ERROR(stream));
    }

The macro only returns pointers to constant strings (in code memory), so
that there is no need to release the returned pointer.

### PB_RETURN_ERROR

Set the error message and return false:

    #define PB_RETURN_ERROR(stream,msg) (sets error and returns false)

This should be used to handle error conditions inside nanopb functions
and user callback functions:

    if (error_condition)
    {
        PB_RETURN_ERROR(stream, "something went wrong");
    }

The *msg* parameter must be a constant string.

### PB_BIND

This macro generates the [pb_msgdesc_t](#pb_msgdesc_t) and associated
arrays, based on a list of fields in [X-macro](https://en.wikipedia.org/wiki/X_Macro) format. :

    #define PB_BIND(msgname, structname, width) ...

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| msgname              | Name of the message type. Expects `msgname_FIELDLIST` macro to exist.
| structname           | Name of the C structure to bind to.
| width                | Number of words per field descriptor, or `AUTO` to use minimum size possible.

This macro is automatically invoked inside the autogenerated `.pb.c`
files. User code can also call it to bind message types with custom
structures or class types.
