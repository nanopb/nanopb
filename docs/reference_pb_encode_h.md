# API reference: pb_encode.h

## Output stream management

### pb_ostream_from_buffer

Constructs an output stream for writing into a memory buffer. It uses an internal callback that
stores the pointer in stream `state` field. :

    pb_encode_ctx_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| buf                  | Memory buffer to write into.
| bufsize              | Maximum number of bytes to write.
| returns              | An output stream.

After writing, you can check `stream.bytes_written` to find out how
much valid data there is in the buffer. This should be passed as the
message length on decoding side.

### pb_write

Writes data to an output stream. Always use this function, instead of
trying to call stream callback manually. :

    bool pb_write(pb_encode_ctx_t *stream, const pb_byte_t *buf, size_t count);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to.
| buf                  | Pointer to buffer with the data to be written.
| count                | Number of bytes to write.
| returns              | True on success, false if maximum length is exceeded or an IO error happens.

> **NOTE:** If an error happens, *bytes_written* is not incremented. Depending on
the callback used, calling pb_write again after it has failed once may
cause undefined behavior. Nanopb itself never does this, instead it
returns the error to user application. The builtin
`pb_ostream_from_buffer` is safe to call again after failed write.

## Message encoding

### pb_encode

Encodes the contents of a structure as a protocol buffers message and
writes it to output stream. :

    bool pb_encode(pb_encode_ctx_t *stream, const pb_msgdesc_t *fields, const void *src_struct);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to.
| fields               | Message descriptor, usually autogenerated.
| src_struct           | Pointer to the message structure. Must match `fields` descriptor.
| returns              | True on success, false on any error condition. Error message is set to `stream->errmsg`.

Normally pb_encode simply walks through the fields description array
and serializes each field in turn. However, submessages must be
serialized twice: first to calculate their size and then to actually
write them to output. This causes some constraints for callback fields,
which must return the same data on every call.

### pb_encode_ex

Encodes the message, with extended behavior set by flags:

    bool pb_encode_ex(pb_encode_ctx_t *stream, const pb_msgdesc_t *fields, const void *src_struct, unsigned int flags);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to.
| fields               | Message descriptor, usually autogenerated.
| src_struct           | Pointer to the message structure. Must match `fields` descriptor.
| flags                | Extended options, see below.
| returns              | True on success, false on any error condition. Error message is set to `stream->errmsg`.

The options that can be defined are:

* `PB_ENCODE_DELIMITED`: Indicate the length of the message by prefixing with a varint-encoded length. Compatible with `parseDelimitedFrom` in Google's protobuf library.
* `PB_ENCODE_NULLTERMINATED`: Indicate the length of the message by appending a zero tag value after it. Supported by nanopb decoder, but not by most other protobuf libraries.

### pb_get_encoded_size

Calculates the length of the encoded message.

    bool pb_get_encoded_size(size_t *size, const pb_msgdesc_t *fields, const void *src_struct);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| size                 | Calculated size of the encoded message.
| fields               | Message descriptor, usually autogenerated.
| src_struct           | Pointer to the data that will be serialized.
| returns              | True on success, false on detectable errors in field description or if a field encoder returns false.

## Manual field encoding

The functions with names `pb_encode_<datatype>` are used when dealing with
callback fields. The typical reason for using callbacks is to have an
array of unlimited size. In that case, [pb_encode](#pb_encode) will
call your callback function, which in turn will call `pb_encode_<datatype>`
functions repeatedly to write out values.

The tag of a field must be encoded first with
[pb_encode_tag_for_field](#pb_encode_tag_for_field). After that, you
can call exactly one of the content-writing functions to encode the
payload of the field. For repeated fields, you can repeat this process
multiple times.

Writing packed arrays is a little bit more involved: you need to use
`pb_encode_tag` and specify `PB_WT_STRING` as the wire
type. Then you need to know exactly how much data you are going to
write, and use [pb_encode_varint](#pb_encode_varint) to write out the
number of bytes before writing the actual data. Substreams can be used
to determine the number of bytes beforehand; see
[pb_encode_submessage](#pb_encode_submessage) source code for an
example.

See [Google Protobuf Encoding Format Documentation](https://developers.google.com/protocol-buffers/docs/encoding)
for background information on the Protobuf wire format.

### pb_encode_tag

Starts a field in the Protocol Buffers binary format: encodes the field
number and the wire type of the data.

    bool pb_encode_tag(pb_encode_ctx_t *stream, pb_wire_type_t wiretype, uint32_t field_number);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to. 1-5 bytes will be written.
| wiretype             | `PB_WT_VARINT`, `PB_WT_64BIT`, `PB_WT_STRING` or `PB_WT_32BIT`
| field_number         | Identifier for the field, defined in the .proto file. You can get it from `field->tag`.
| returns              | True on success, false on IO error.

### pb_encode_tag_for_field

Same as [pb_encode_tag](#pb_encode_tag), except takes the parameters
from a `pb_field_iter_t` structure.

    bool pb_encode_tag_for_field(pb_encode_ctx_t *stream, const pb_field_iter_t *field);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to. 1-5 bytes will be written.
| field                | Field iterator for this field.
| returns              | True on success, false on IO error or unknown field type.

This function only considers the `PB_LTYPE` of the field. You can use it from
your field callbacks, because the source generator writes correct `LTYPE`
also for callback type fields.

Wire type mapping is as follows:

| LTYPEs                                           | Wire type
|--------------------------------------------------|-----------------
| BOOL, VARINT, UVARINT, SVARINT                   | PB_WT_VARINT
| FIXED64                                          | PB_WT_64BIT
| STRING, BYTES, SUBMESSAGE, FIXED_LENGTH_BYTES    | PB_WT_STRING
| FIXED32                                          | PB_WT_32BIT

### pb_encode_varint

Encodes a signed or unsigned integer in the
[varint](http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints)
format. Works for fields of type `bool`, `enum`, `int32`, `int64`, `uint32` and `uint64`:

    bool pb_encode_varint(pb_encode_ctx_t *stream, uint64_t value);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to. 1-10 bytes will be written.
| value                | Value to encode, cast to `uint64_t`.
| returns              | True on success, false on IO error.

> **NOTE:** Value will be converted to `uint64_t` in the argument.
> To encode signed values, the argument should be cast to `int64_t` first for correct sign extension.

### pb_encode_svarint

Encodes a signed integer in the [zig-zagged](https://developers.google.com/protocol-buffers/docs/encoding#signed_integers) format.
Works for fields of type `sint32` and `sint64`:

    bool pb_encode_svarint(pb_encode_ctx_t *stream, int64_t value);

(parameters are the same as for [pb_encode_varint](#pb_encode_varint)

### pb_encode_string

Writes the length of a string as varint and then contents of the string.
Works for fields of type `bytes` and `string`:

    bool pb_encode_string(pb_encode_ctx_t *stream, const pb_byte_t *buffer, size_t size);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to.
| buffer               | Pointer to string data.
| size                 | Number of bytes in the string. Pass `strlen(s)` for strings.
| returns              | True on success, false on IO error.

### pb_encode_fixed32

Writes 4 bytes to stream and swaps bytes on big-endian architectures.
Works for fields of type `fixed32`, `sfixed32` and `float`:

    bool pb_encode_fixed32(pb_encode_ctx_t *stream, const void *value);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to. 4 bytes will be written.
| value                | Pointer to a 4-bytes large C variable, for example `uint32_t foo;`.
| returns              | True on success, false on IO error.

### pb_encode_fixed64

Writes 8 bytes to stream and swaps bytes on big-endian architecture.
Works for fields of type `fixed64`, `sfixed64` and `double`:

    bool pb_encode_fixed64(pb_encode_ctx_t *stream, const void *value);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to. 8 bytes will be written.
| value                | Pointer to a 8-bytes large C variable, for example `uint64_t foo;`.
| returns              | True on success, false on IO error.

### pb_encode_float_as_double

Encodes a 32-bit `float` value so that it appears like a 64-bit `double` in the encoded message.
This is sometimes needed when platforms like AVR that do not support 64-bit `double` need to communicate using a
message type that contains `double` fields.

    bool pb_encode_float_as_double(pb_encode_ctx_t *stream, float value);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to. 8 bytes will be written.
| value                | Float value to encode.
| returns              | True on success, false on IO error.

### pb_encode_submessage

Encodes a submessage field, including the size header for it. Works for
fields of any message type.

    bool pb_encode_submessage(pb_encode_ctx_t *stream, const pb_msgdesc_t *fields, const void *src_struct);

|                      |                                                        |
|----------------------|--------------------------------------------------------|
| stream               | Output stream to write to.
| fields               | Pointer to the autogenerated message descriptor for the submessage type, e.g. `MyMessage_fields`.
| src                  | Pointer to the structure where submessage data is.
| returns              | True on success, false on IO errors, pb_encode errors or if submessage size changes between calls.

In Protocol Buffers format, the submessage size must be written before
the submessage contents. Therefore, this function has to encode the
submessage twice in order to know the size beforehand.

If the submessage contains callback fields, the callback function might
misbehave and write out a different amount of data on the second call.
This situation is recognized and `false` is returned, but garbage will
be written to the output before the problem is detected.
